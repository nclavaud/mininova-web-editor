{"version":3,"sources":["midi.js","webmidi.js","components/Controls.js","components/NotSupported.js","components/Devices.js","App.js","serviceWorker.js","index.js"],"names":["SYSEX_START","MIDINOVA_SIGNATURE","cc","control","value","Uint8Array","nrpn","msb","lsb","isValidSysexValue","sysex","values","every","RangeError","concat","send","device","msg","waveforms","Controls","currentPatch","loadPatch","output","onClick","event","target","R","waveform","label","key","NotSupported","href","Devices","onIncomingMidiMessage","selectPatch","input","setInput","setOutput","useState","midiSupport","setMidiSupport","availableInputs","setAvailableInputs","availableOutputs","setAvailableOutputs","useEffect","detectDevices","access","console","log","outputDevicesFound","outputs","next","done","push","inputDevicesFound","inputs","navigator","requestMIDIAccess","then","onstatechange","e","map","id","name","onmidimessage","selectInput","selectOutput","sequenceHandshake","sequencePreHandshake","sequenceLoadCurrentPatch","App","setCurrentPatch","message","data","setTimeout","Boolean","window","location","hostname","match","ReactDOM","render","StrictMode","document","getElementById","serviceWorker","ready","registration","unregister","catch","error"],"mappings":"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","file":"static/js/main.feb95ad5.chunk.js","sourcesContent":["const CC = 0xB0;\nconst NRPN_MSB = 0x63;\nconst NRPN_LSB = 0x62;\nconst NRPN_VAL = 0x06;\nconst SYSEX_START = 0xF0;\nconst SYSEX_END = 0xF7;\nconst MIDINOVA_SIGNATURE = [0x00, 0x20, 0x29, 0x03, 0x01];\nexport const PROGRAM_CHANGE = 0xC0;\n\nexport const cc = (control, value) => new Uint8Array([\n  CC, control, value,\n]);\n\nexport const nrpn = (msb, lsb, value) => new Uint8Array([\n  CC, NRPN_MSB, msb,\n  CC, NRPN_LSB, lsb,\n  CC, NRPN_VAL, value,\n]);\n\nconst isValidSysexValue = value => value >= 0x00 && value <= 0x7F;\n\nexport const sysex = values => {\n  if (!values.every(isValidSysexValue)) {\n    throw new RangeError(\"Sequence contains invalid sysex value\");\n  }\n\n  return new Uint8Array(\n    [SYSEX_START]\n      .concat(MIDINOVA_SIGNATURE)\n      .concat(values)\n      .concat([SYSEX_END])\n  );\n};\n","export const send = (device, msg) => device && device.send(msg);\n","import React from 'react';\nimport * as R from 'ramda';\nimport { cc, nrpn } from '../midi';\nimport { send } from '../webmidi';\n\nconst waveforms = [\n  0, 'Sine',\n  1, 'Triangle',\n  2, 'Sawtooth',\n];\n\nfunction Controls({ currentPatch, loadPatch, output }) {\n  const changeOctave = () => send(output, cc(13, 0));\n  const activateArp = () => send(output, nrpn(0, 122, 47));\n  const deactivateArp = () => send(output, nrpn(0, 122, 46));\n  const selectPrevPatch = () => send(output, nrpn(63, 0, 0));\n  const selectNextPatch = () => send(output, nrpn(63, 0, 2));\n  const selectOsc1Wave = event => send(output, cc(19, event.target.value));\n\n  return (\n    <div>\n      <h3>Patch</h3>\n      <p>Current patch: {currentPatch}</p>\n      <button onClick={selectPrevPatch}>Prev patch</button>\n      <button onClick={selectNextPatch}>Next patch</button>\n      <button onClick={loadPatch}>Load patch</button>\n      <h3>Oct / Arp</h3>\n      <button onClick={changeOctave}>Change octave</button>\n      <button onClick={activateArp}>Arp ON</button>\n      <button onClick={deactivateArp}>Arp OFF</button>\n      <h3>Oscillators</h3>\n      <h4>Oscillator 1</h4>\n      <select onClick={selectOsc1Wave}>\n        {R.map(([waveform, label]) => (\n          <option key={waveform} value={waveform}>{label}</option>\n        ), R.splitEvery(2, waveforms))}\n      </select>\n    </div>\n  );\n}\n\nexport default Controls;\n","import React from 'react';\n\nfunction NotSupported() {\n  return (\n    <div>\n      <p>It looks like your browser does not support MIDI.</p>\n      <p>MIDI access is an experimental technology. Check the list of compatible browsers in the <a href=\"https://developer.mozilla.org/en-US/docs/Web/API/MIDIAccess#Browser_compatibility\">Browser compatibility table </a>.</p>\n    </div>\n  );\n}\n\nexport default NotSupported;\n","import React, { useState, useEffect } from 'react';\nimport * as R from 'ramda';\nimport NotSupported from './NotSupported.js';\n\nfunction Devices({\n  onIncomingMidiMessage,\n  selectPatch,\n  input,\n  setInput,\n  output,\n  setOutput\n}) {\n  const [midiSupport, setMidiSupport] = useState(null);\n  const [availableInputs, setAvailableInputs] = useState(null);\n  const [availableOutputs, setAvailableOutputs] = useState(null);\n\n  const selectOutput = id => {\n    const device = R.find(R.propEq('id', id))(availableOutputs);\n    setOutput(device);\n    selectPatch(device);\n  };\n\n  const selectInput = id => {\n    if (input) {\n      input.onmidimessage = null;\n    }\n    const device = R.find(R.propEq('id', id))(availableInputs);\n    device.onmidimessage = onIncomingMidiMessage;\n    setInput(device);\n  };\n\n  useEffect(() => {\n\n    const detectDevices = access => {\n      console.log('Detecting devices');\n\n      const outputDevicesFound = [];\n      const outputs = access.outputs.values();\n      for (let output = outputs.next(); output && !output.done; output = outputs.next()) {\n        outputDevicesFound.push(output.value);\n      }\n      setAvailableOutputs(outputDevicesFound);\n\n      const inputDevicesFound = [];\n      const inputs = access.inputs.values();\n      for (let input = inputs.next(); input && !input.done; input = inputs.next()) {\n        inputDevicesFound.push(input.value);\n      }\n      setAvailableInputs(inputDevicesFound);\n    };\n\n    if (!navigator.requestMIDIAccess) {\n      setMidiSupport(false);\n      return;\n    } else {\n      setMidiSupport(true);\n    }\n\n    navigator.requestMIDIAccess({ sysex: true }).then(access => {\n      access.onstatechange = e => {\n        detectDevices(access);\n      }\n      detectDevices(access);\n    });\n  }, []);\n\n  if (null === midiSupport) {\n    return <p>Detecting MIDI support...</p>;\n  } else if (!midiSupport) {\n    return <NotSupported />;\n  }\n\n  if (null === availableInputs || null === availableOutputs) {\n    return <div>Detecting MIDI devices...</div>;\n  }\n\n  return (\n    <div>\n      <p>Available devices:</p>\n      <ul>\n        {availableInputs.map(device => (\n          <li key={device.id}>\n            IN {device.name}\n            {input && device.id === input.id\n              ? ' (selected)'\n              : <button onClick={() => selectInput(device.id)}>select</button>\n            }\n          </li>\n        ))}\n        {availableOutputs.map(device => (\n          <li key={device.id}>\n            OUT {device.name}\n            {output && device.id === output.id\n              ? ' (selected)'\n              : <button onClick={() => selectOutput(device.id)}>select</button>\n            }\n          </li>\n        ))}\n      </ul>\n    </div>\n  );\n}\n\nexport default Devices;\n","import React, { useState } from 'react';\nimport { Controls, Devices } from './components';\nimport { nrpn, sysex, PROGRAM_CHANGE } from './midi';\nimport { send } from './webmidi';\n\n// is it really handshake?\nconst sequenceHandshake = [0x7F, 0x60, 0x21, 0x00, 0x00, 0x00, 0x00];\nconst sequencePreHandshake = [0x7F, 0x62, 0x01, 0x00, 0x00, 0x00, 0x00];\nconst sequenceLoadCurrentPatch = [0x7F, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00];\n\nfunction App() {\n  const [input, setInput] = useState(null);\n  const [output, setOutput] = useState(null);\n  const [currentPatch, setCurrentPatch] = useState(null);\n\n  const onIncomingMidiMessage = message => {\n    if (message.data[0] === PROGRAM_CHANGE) {\n      setCurrentPatch(message.data[1]);\n    } else {\n      console.log(message);\n    }\n  };\n\n  const loadPatch = () => send(output, sysex(sequenceLoadCurrentPatch));\n\n  const selectPatch = output => {\n    send(output, sysex(sequencePreHandshake));\n    setTimeout(() => send(output, sysex(sequenceHandshake)), 1000);\n    setTimeout(() => send(output, nrpn(63, 0, 1)), 2000);\n    setTimeout(loadPatch, 3000);\n  };\n\n  return (\n    <div>\n      <Devices\n        onIncomingMidiMessage={onIncomingMidiMessage}\n        selectPatch={selectPatch}\n        input={input}\n        setInput={setInput}\n        output={output}\n        setOutput={setOutput}\n      />\n      <Controls\n        currentPatch={currentPatch}\n        loadPatch={loadPatch}\n        input={input}\n        output={output}\n      />\n    </div>\n  );\n}\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' },\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready\n      .then(registration => {\n        registration.unregister();\n      })\n      .catch(error => {\n        console.error(error.message);\n      });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}